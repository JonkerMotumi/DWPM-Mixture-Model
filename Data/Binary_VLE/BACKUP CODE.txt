#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""

"""
#%% Imports
from __future__ import division
from scipy.interpolate import interp1d
import data_handling, Van_der_Waals, numpy
VdW = Van_der_Waals.VdW()

try: #DEBUGGING; DELETE
    del s
    del p
    del I
except NameError:
    pass

#%% Inputs (will be called if no input container "I" is defined before exec)
def inputs():
    I = {# Model inputs
         'Compounds'    : ['benzene','cyclohexane'], # Compound to simulate.
         'Mixture model': 'VdW standard', #  'VdW standard' 'DWMP'
         'Model'       : 'Adachi-Lu',   # Model used in the simulation, 
                                     # options:
                                      # 'Soave'                   
                                      # 'Adachi-Lu'   
         

         # Optional inputs
         'T'           : 281.15,  # 281.15
         'P'           : 6278.150329,   # 
         
                    # 6492.799322	x1 = 0.4535 y1= 0.4605
                    # Psat 1 = 6071.500625 @ 283.15
                    # Psat 2 = 6342.145033
         
         # NOTE: Using Psat_V_roots, @ T = 283.15:
          # Psat 1 = 6174.7757144388343
          # Psat 2 = 4759.7154146201701
         
         # NOTE: Using Psat_V_roots, @ T = 287.15:
          # Psat 1 = 7524.4499990006861
          # Psat 2 = 5842.1051091283525
         
         
# datapoint = array([0.4535,0.4605]) # @ P = 6492.799322 T = 281.15  

                         #comp. 1  Psat = 5462.722077  
                         #comp. 2  Psat = 5714.421355
                         # HIgh -ish 6492.799322
         'Phase split' : True, # Find phase split at specified T, P.
         'Save results': True,
         'Plot binary' : True,
         'Fig. number' : 2,
         'Plot pure'   : False,       
         'Plot options': {'text.usetex' : True, # Options for all plots
                          'font.size' : 11,            
                          'font.family' : 'lmodern',
                          'text.latex.unicode': True

                          },
         }

    return I
#%% Define paramter class
class MixParameters:
    """Store mixture and pure parameters in the same class."""
    def __init__(self):
        #self.name = name
        self.c = []    # creates a new empty list for components 
        self.c.append('nan') #  Define an empty set in index 0 

    def mixture_parameters(self,Data,I):
        """Mixture model parameters"""
        M = {'k12' : Data['k12'][0],
             'k1'  : Data['k1'][0],
             'k2'  : Data['k2'][0],
             'r'   : Data['r'][0],
             's'   : Data['s'][0],
             'T'   : Data['T (K)'],
             'P'   : Data['P (Pa)'],
             'x1'  : Data['x1'],
             'y1'  : Data['y1'],
             'Model': I['Mixture model']
             }
             
        for key, value in M.iteritems(): # Filter out '' values
            if not value.__class__ == float:
                M[key] = filter(lambda a: a != '', value)
        
        self.m = M

    def parameters(self,Data,I):
        """
        Move data container to parameter output dictionary and find the 
        critical Van der Waals contants if not defined.
        
        Parameters
        ----------
        Data : Dictionary containing data loaded from the stored .csv file.
        
        I : Input dictionary, must contain key 'Model' defining the a parameter
            dependancy model.
        """
        p = {'T'   : Data['T (K)'],
             'P'   : Data['P (Pa)'],
             'T_c' : Data['T_c (K)'][0],
             'P_c' : Data['P_c (Pa)'][0],
             'V_c' : Data['V_c (m3 mol-1)'][0],
             'Z_c' : Data['Z_c'][0],
             'R'   : Data['R (m3 Pa K-1 mol-1)'][0],
             'w'   : Data['w'][0],
             'a_c' : Data['a_c (Pa m6 mol-2)'][0],
             'b_c' : Data['b_c (m3 mol-1)'][0],
             'vT'  : Data['virialT'],
             'vB'  : Data['virialB'],
             'Model': I['Model']
             }
    
        if I['Model'] == 'Adachi-Lu': # Find model params if not defined
            p['m'] = Data['m (Adachi-Lu)'][0]
        elif I['Model'] == 'Soave':
            p['m'] = Data['m (Soave)'][0]
    
        if p['a_c'] == '' or p['b_c'] == '': 
            p['b_c'] = p['R']*p['T_c']/(8*p['P_c']) 
            p['a_c'] = 27*(p['R']**2)*(p['T_c']**2)/(64.0*p['P_c'])       
        else:
            pass
    
        for key, value in p.iteritems(): # Filter out '' values
            if not value.__class__ == float:
                p[key] = filter(lambda a: a != '', value)
        
        self.c.append(p)

#%% Define state variable class
class state:
    """Class defining state vars """
    def __init__(self):
        self.s = {} # System state vars 
        self.c = [] # creates a new empty list for components 
        self.c.append('nan') #  Define an empty set in index 0 
        
    def mixed(self):
        self.m = {} # Mixture states
        
    def pure(self):
        self.c.append({}) # Pure component states
        
#%% Define binary mixture models
def a_mix(s,p):
    """
    # Return a_mix at x_1, x_2, for specified a11, a22, a12, a21, r, s
    """  
    if p.m['Model'] == 'VdW standard':
        return   s.c[1]['a'] * s.c[1]['x']**2 \
               + 2*s.m['a12'] * s.c[1]['x'] * s.c[2]['x'] \
               + s.c[2]['a'] * s.c[2]['x']**2
        
    if p.m['Model'] == 'DWMP':
        raise IOError('DWMP not implemented yet')
    
def b_mix(s,p):
    return s.c[1]['x']*s.c[1]['b'] + s.c[2]['x']*s.c[2]['b']
    
def a12(s,p): # TO DO TRY MODEL  p.m['k12'] ==  k1*x1 + k2*x2 
    from math import sqrt
    return (1 - p.m['k12']) * sqrt(s.c[1]['a']*s.c[2]['a'])   
    
def b12(s,p): # NOTE: Not currently in use for VdW Standard or DWMP! 
    from math import sqrt
    return sqrt(s.c[1]['b']*s.c[2]['b']) 
#%% g - g_ref (add g of volume phase)
def g_R_v(s,p):
    '''g_R_v(T,P) of a single component'''
    from math import log
    return s['P']*s['V_v']/(p['R']*s['T']) - 1.0 - log(s['P']/(p['R']*s['T']))\
    - log(s['V_v'] - s['b']) - s['a']/(p['R']*s['T']*s['V_v'])
    
def g_R_l(s,p):
    '''g_R_l(T,P) of a single component'''
    from math import log
    return s['P']*s['V_l']/(p['R']*s['T']) - 1.0 - log(s['P']/(p['R']*s['T']))\
    - log(s['V_l'] - s['b']) - s['a']/(p['R']*s['T']*s['V_l'])
    
def del_g_IG_v(s1,s2):
    """del_g_IG_v(x), change in gibbs energy for mixing of ideal gasses"""
    from math import log
    if s1['y'] == 0.0: 
        return 0.0 # should be = 0 as s2['y']*log(s2['y']) = 1*log(1) = 0
    if s2['y'] == 0.0:
        return 0.0
    return s1['y']*log(s1['y']) + s2['y']*log(s2['y'])
    
def del_g_IG_l(s1,s2):
    """del_g_IG_v(x), change in gibbs energy for mixing of ideal solutions"""
    from math import log
    if s1['x'] == 0.0: 
        return 0.0 # should be = 0 as s2['x']*log(s2['x']) = 1*log(1) = 0
    if s2['x'] == 0.0:
        return 0.0
    return s1['x']*log(s1['x']) + s2['x']*log(s2['x'])   
    
def del_g_v_min_l0(s,p):
    """This function returns the analytical solution of the integral between 
    the Gibbs energy of the Vapour phase of a pure component and the liquid 
    phase pure component reference state."""
    from math import log
    return 2*s['a']/(p['R'] * s['T']) *((1/s['V_l']) - (1/s['V_v'])) \
    + s['b'] * ((1/(s['V_v'] - s['b'])) - (1/(s['V_l'] - s['b']))) \
    + log((s['V_l'] - s['b'])/(s['V_v'] - s['b']))
            
#%% dg_mix
def del_g_mix(s, p, x_1=None, update_pure=False, derivative=None):
    """ 
    Returns the change in gibbs energy Gmix/RT at specified composition
    x1 = x[0], Pressure and Temperature
    """
    #%% Update new x_1 if specified
    if x_1 is not None:
        s.c[1]['x'],s.c[2]['x'] = x_1, (1.0-x_1)
        s.c[1]['y'],s.c[2]['y'] = s.c[1]['x'],s.c[2]['x']    
    #%% Find params at current composition and P,T conditions
    if update_pure:
        s.c[1]['a'] = VdW.a_T(s.c[1],p.c[1])['a']
        s.c[2]['a'] = VdW.a_T(s.c[2],p.c[2])['a']
    try: # Note: Highly non-linear models
        s.m['a12'] = a12(s,p)
        s.m['a']   = a_mix(s,p)
        #s.m['b12'] = b12(s,p)  # Not currently in use
        s.m['b']   = b_mix(s,p)
    except (ValueError, ZeroDivisionError): # DO NOT RAISE, SET PENALTY
        s.s['Math Error'] = True
        print 'WARNING: Math Domain error at %s Pa %s K' %(s.s['P'],s.s['T'])
        s.m['a12'], s.m['a'], s.m['b12'], s.m['b'] = (0.0,)*4
    #%% Find Volume Roots ('V_v' and 'V_l') at P, T, a, b for both components.
    if update_pure:
        s.c[1], s.c[2] = VdW.V_root(s.c[1], p.c[1]), VdW.V_root(s.c[2], p.c[2])
    s.m = VdW.V_root(s.m, p.m) # 'V_v' and 'V_l' mixture volumes at x1, x2
    #%% Find Change in gibbs energies of mixing
    try:
        # del g_mix^R =  g_mix^R(T,P) - SIGMA x_i * g_i^R(T,P)
         # del g_mix^R for each phases.
        g_Res_Pure = - s.c[1]['x']*g_R_l(s.c[1],p.c[1]) \
                     - s.c[2]['x']*g_R_l(s.c[2],p.c[2])
        s.m['del g_mix^R l'] = g_R_l(s.m,p.m) \
                               + g_Res_Pure
#                               - s.c[1]['x']*g_R_l(s.c[1],p.c[1]) \
#                               - s.c[2]['x']*g_R_l(s.c[2],p.c[2])

               # NOTE!!! x = y = linspace for mapping del g_mix^R
        s.m['del g_mix^R v'] = g_R_v(s.m,p.m) \
                               + g_Res_Pure
#                               - s.c[1]['x']*g_R_l(s.c[1],p.c[1]) \
#                               - s.c[2]['x']*g_R_l(s.c[2],p.c[2])
                               #- s.c[1]['y']*g_R_v(s.c[1],p.c[1]) \
                               #- s.c[2]['y']*g_R_v(s.c[2],p.c[2])
        
        # Calculate pure vapour phase total Gibbs energy minus liquid reference
         # state
#        s.c[1]['g_1^V,0 - g_1^l,0'] = del_g_v_min_l0(s.c[1],p.c[1])
#        s.c[2]['g_2^V,0 - g_2^l,0'] = del_g_v_min_l0(s.c[2],p.c[2])
                                
        # del g_mix(T,P,x) = del g_mix^R(T,P,x) + del g^IG(T,P,x)                
        s.m['del g_mix l'] = s.m['del g_mix^R l'] + del_g_IG_l(s.c[1],s.c[2])
                                                        
        s.m['del g_mix v'] = s.m['del g_mix^R v'] + del_g_IG_v(s.c[1],s.c[2]) \
                             #+ s.c[1]['y']*(s.c[1]['g_1^V,0 - g_1^l,0']) \
                             #+ s.c[2]['y']*(s.c[2]['g_2^V,0 - g_2^l,0']) 

        #s.m['del g_mix^R'] = min(s.m['del g_mix^R l'], s.m['del g_mix^R v'])
        
        s.m['del g_mix'] = min(s.m['del g_mix l'], s.m['del g_mix v'])

        s.s['Math Error'] = False
    except (ValueError, ZeroDivisionError):
        s.s['Math Error'] = True
        print 'WARNING: Math Domain error in del_g_mix(s,p)!'
        s.m['del g_mix l'], s.m['del g_mix v'] = 0.0, 0.0

    return s
#%% TEMPORARY (CENTRAL FD) DERIVATIVE ESTIMATE; replace with analyt-est. hybrid
def d_del_g_mix_dx1(s, p, x_1, dx=1e-6):
    return (del_g_mix(s, p, x_1 + dx).m['del g_mix'] \
            - del_g_mix(s, p, x_1 - dx).m['del g_mix'])/dx
#%%
def g_range(s, p, x_r): 
    """
    Formerly in phase_split func, solve g_mix(x) over x at a P, T
    TO DO OPTIMIZE WITH MAP FUNCTION/ COMPILE IN C / def append etc."""
    from numpy import linspace
    #% Initialize
    s.s['del g_mix l soln'], s.s['del g_mix v soln'] = [], []
    s.s['del g_mix soln'], s.s['Math Error soln'] = [], []
    s.c[1]['x_range'], s.c[2]['x_range'] = linspace(0,1,x_r), linspace(1,0,x_r)
    #% Find pure component parameters at current s['P'], s['T']
    s.c[1]['a'] = VdW.a_T(s.c[1],p.c[1])['a']
    s.c[2]['a'] = VdW.a_T(s.c[2],p.c[2])['a']
    s.c[1], s.c[2] = VdW.V_root(s.c[1], p.c[1]), VdW.V_root(s.c[2], p.c[2])
    #% Solve for x_range 
     # TO DO replace s.c[1]['x_range'] with generator function
    for i in range(len(s.c[1]['x_range']-1)): 
        s.c[1]['x'],s.c[2]['x'] = s.c[1]['x_range'][i],s.c[2]['x_range'][i]
    # To avoid future confusions, we will set extra var y1 = x1, y2 = x2
        s.c[1]['y'],s.c[2]['y'] = s.c[1]['x'],s.c[2]['x'] 
        s = del_g_mix(s, p, update_pure=False)   #.m['del g_mix l']
        s.s['del g_mix l soln'].append(s.m['del g_mix l'])
        s.s['del g_mix v soln'].append(s.m['del g_mix v'])
        s.s['del g_mix soln'].append(s.m['del g_mix'])
        s.s['Math Error soln'].append(s.s['Math Error'])
   
    return s
                    
#%%  
def pseudo_analytical_sys(x, s, p, dx_constraint = 1e-20):
    """
    Returns a system of the 4 Pseudo Analytical equations using the common 
    tangent.
    """
    [s.c[1]['x_alpha'], s.c[1]['x_beta'], m, c] = x
    #% Constraints
    P = 0.0 # Penalty
    if c > 1e-15: # If c not <= 0
        P += 1.1**(10.0*abs(c))
    if m + c > 1e-15:
        P += 1.1**(10.0*abs(abs(m) + abs(c)))
    if abs(s.c[1]['x_alpha'] - s.c[1]['x_beta'])  < dx_constraint:
        P += 1.1**(1e-5*abs(1/(s.c[1]['x_alpha'] - s.c[1]['x_beta']) ))
    #% Return sys
    return [del_g_mix(s, p, x_1=s.c[1]['x_alpha']).m['del g_mix'] \
            - (m*s.c[1]['x_alpha'] + c) + P,
            d_del_g_mix_dx1(s, p, x_1=s.c[1]['x_alpha']) - m  + P,
            del_g_mix(s, p, x_1=s.c[1]['x_beta']).m['del g_mix'] \
            - (m*s.c[1]['x_beta'] + c)  + P,
            d_del_g_mix_dx1(s, p, x_1=s.c[1]['x_beta']) - m  + P
            ]

#%%
def phase_split(s, p, method='Pseudo-Analytical', est = None, x_r = 100):
    """
    Note if est = None, phases are detectect and found otherwise only a 
    specific equilibruim point is found, if it exists.
    
    TO DO: - Implement d^2 g^R / d x_1 ^2 analysis to detect LLE (Kontogeoris,
        p. 456)
    
     - return s.m['x1'] s.m['y1'] at specified parameters and P, T 

    If est is not None:
    Returns the phase split mole fractions x1 and y1 calculated near the 
    specified data or estimated value pair est=[x1_d,y1_d].
    
    NOTE, pressures and pure component params must be updated in s before call    
    
    TO DO; put "Find equilibrium close to the estimated phase split point" cell
    into its own function so that multiple equilibrium points can be found, if
    detected.
    """
    #%% if est in None, detect phase split
    if est is None:
        from scipy.signal import argrelextrema
        from numpy import linspace, less, array
        s = g_range(s, p, x_r) # Get points to detect phase seperation
        s.s['g_min'] = argrelextrema(array(s.s['del g_mix soln']), less) 
        # TO DO; FINISH THIS SCRIPT
         # SET est to  d^2 g^R / d x_1 ^2 = 0 roots
         # SET MEthond to (Kontogeoris, p. 456)
        
    #%% Find equilibrium close to the estimated phase split point
    if est is not None:
        from scipy.optimize import fsolve

        #% Update pure volumes and paramters at current s['P'], s['T']
        s.c[1]['a'] = VdW.a_T(s.c[1],p.c[1])['a']
        s.c[2]['a'] = VdW.a_T(s.c[2],p.c[2])['a']
        s.c[1], s.c[2] = VdW.V_root(s.c[1], p.c[1]), VdW.V_root(s.c[2], p.c[2])
        
        if method == 'Pseudo-Analytical':
            #%% Estimates for solver
            [s.c[1]['x_alpha'], s.c[1]['x_beta']] = est
            m_est = (del_g_mix(s, p, x_1=s.c[1]['x_beta']).m['del g_mix'] \
                    - del_g_mix(s, p, x_1=s.c[1]['x_alpha']).m['del g_mix']) \
                    /(s.c[1]['x_beta'] - s.c[1]['x_alpha'] + 1e-10)
            c_est = del_g_mix(s, p, x_1=s.c[1]['x_beta']).m['del g_mix'] \
                    - m_est*s.c[1]['x_beta']
            #% Solve
            dx_constraint = 0.4*(s.c[1]['x_beta'] - s.c[1]['x_alpha'])
            ans = fsolve(pseudo_analytical_sys,
                         [s.c[1]['x_alpha'], s.c[1]['x_beta'], m_est, c_est],
                         args=(s, p, dx_constraint) )
    #%% Find phase of equilibrium point TO DO; RECHECK THIS CELL
        s.c[1]['x_alpha'], s.c[1]['x_beta'] = ans[0], ans[1]
        g_a = del_g_mix(s, p, x_1=s.c[1]['x_alpha'])
        g_b = del_g_mix(s, p, x_1=s.c[1]['x_beta'])
        g_a.m['del g_mix^R l'] 

        if g_a.m['del g_mix^R l'] < g_a.m['del g_mix^R v']:
            s.m['x1'] = s.c[1]['x_alpha']
            if g_b.m['del g_mix^R v'] < g_b.m['del g_mix^R l']:
                   s.m['y1'] = s.c[1]['x_beta']
            else: # Same phase!
                s.m['No Phase Penatly'] = True
                s.m['x1'], s.m['y1'] = (0.0,)*2
                
        elif g_a.m['del g_mix^R v'] < g_a.m['del g_mix^R l']:
            s.m['y1'] = s.c[1]['x_alpha']
            if g_b.m['del g_mix^R l'] < g_b.m['del g_mix^R v']:
                   s.m['x1'] = s.c[1]['x_beta']
            else: # Same phase!
                s.m['No Phase Penatly'] = True
                s.m['x1'], s.m['y1'] = (0.0,)*2
        #s.m['ans'] = ans # DEBUGGING; DELETE

    return s, p
#%%    
def optim_mixture_parameter(s, p):
    """
    Stuff happens here, parameters come out.
    """
    from scipy.optimize import fmin_l_bfgs_b, anneal
    from numpy import array
    
    # b11 and b22 taken as the critical parameters
    s.c[1]['b'], s.c[2]['b'] = p.c[1]['b_c'], p.c[2]['b_c']  
    
    #%% Trim Azeotrope and single phase points
    
    p.m['x1 Pure vapour'], p.m['y1 Pure vapour'], p.m['P Pure vapour'], \
    p.m['T Pure vapour'], p.m['x1 Pure liquid'], p.m['y1 Pure liquid'], \
    p.m['P Pure liquid'], p.m['T Pure liquid'], p.m['x1 Azeo'], p.m['y1 Azeo']\
    , p.m['P Azeo'], p.m['T Azeo'] = ([],)*12
    return
    def trim_conditions(p, i): 
        """Defined here to simplify proceeding loop readablity"""
        if abs(p.m['x1'][i] - p.m['y1'][i]) < 1e-5:
            if p.m['x1'][i] > 0.9999 and p.m['y1'][i] > 0.9999:
                p.m['x1 Pure vapour'].append(p.m['x1'].pop(i))
                p.m['y1 Pure vapour'].append(p.m['y1'].pop(i))
                p.m['P Pure vapour'].append(p.m['P'].pop(i))
                p.m['T Pure vapour'].append(p.m['T'].pop(i))
                return p
            if p.m['x1'][i] < 1e-5 and p.m['y1'][i] < 1e-5:
                p.m['x1 Pure liquid'].append(p.m['x1'].pop(i))
                p.m['y1 Pure liquid'].append(p.m['y1'].pop(i))
                p.m['P Pure liquid'].append(p.m['P'].pop(i))
                p.m['T Pure liquid'].append(p.m['T'].pop(i))
                return p
            else:
                p.m['x1 Azeo'].append(p.m['x1'].pop(i))
                p.m['y1 Azeo'].append(p.m['y1'].pop(i))
                p.m['P Azeo'].append(p.m['P'].pop(i))
                p.m['T Azeo'].append(p.m['T'].pop(i))
                return p

    for i in range(len(p.m['P'])):
        # Stop loop when index > len(p.m['P']) (where p.m['P'] is trimed)
        if i > len(p.m['P'])-2:
            if abs(p.m['x1'][i] - p.m['y1'][i]) < 1e-5:
                p = trim_conditions(p, i)
                
            break
        # WHEN CONDITION IS MET, Should redo (same i index now shifted back)
        while abs(p.m['x1'][i] - p.m['y1'][i]) < 1e-5:
            p = trim_conditions(p, i)
                 
    #%% Error func (over all data points)
    def error(k12, s, p):
        """
        Returns the error function at specified paramters.
        
        TO DO: ADD PUNISHMENT FOR MATH ERRORS (Every for loop?)
        """
        # Init error over data set
        #s = args[0]
        #p = args[1]
        print p.m['P'][0]
        if p.m['Model'] == 'VdW standard':
            p.m['k12'] = k12
            
        err = 0.0

        #%% Errors related to pure phases and Azeotropes
        # TO DO; Are Pure phase checks needed since mix params do not depend
        # on pure VdW behavior?

#        for i in range(len(p.m['x1 Pure vapour'])): # Vapour Pres. penalty
#        # TO DO; Use del_g_v_min_l0(s,p) g_mix min ?? 
#        # INSPECT THEORETICAL VIABILITY
#            # Update values
#            s.s['P'], s.s['T'] = p.m['P Pure vapour'][i], \
#                                 p.m['T Pure vapour'][i]
#            s.m['P'], s.c[1]['P'], s.c[2]['P'] = (s.s['P'],)*3
#            s.m['T'], s.c[1]['T'], s.c[2]['T'] = (s.s['T'],)*3
#            s.c[1]['a'] = VdW.a_T(s.c[1],p.c[1])['a']
#            s.c[2]['a'] = VdW.a_T(s.c[2],p.c[2])['a']
#            
#            g_v_l = del_g_v_min_l0(s.c[1],p.c[1])
#                       
#            del_g_mix(s, p, x_1=p.m['x1 Pure vapour'][i], update_pure=True)
#            if 
        #% Azeotropes penatly    
        for i in range(len(p.m['P Azeo'])):
            # Update values
            s.s['P'], s.s['T'] = p.m['P Azeo'][i], \
                                 p.m['T Azeo'][i]
            s.m['P'], s.c[1]['P'], s.c[2]['P'] = (s.s['P'],)*3
            s.m['T'], s.c[1]['T'], s.c[2]['T'] = (s.s['T'],)*3
            # Find difference in Gibbs energies between liq and vapour
            dg_v_l = del_g_mix(s, p, x_1=p.m['y1 Azeo'][i], \
            update_pure=True).m['del g_mix'] \
            - del_g_mix(s, p, x_1=p.m['x1 Azeo'][i], \
            update_pure=True).m['del g_mix'] 
            if dg_v_l > 1e-6:
                err += 10**dg_v_l
  
#            x1_diff = abs(p.m['x1'][i] - p.m['y1'][i]) 
#            if x1_diff < 1e-6 and True:
#                err += 10.0**x1_diff
#            #% Wrong pure phase penalty
#            if abs(p.m['x1'][i] - p.m['y1'][i]) < 1e-6: 
#                err += 10.0**abs(p.m['x1'][i] - p.m['y1'][i])
        #%% Find phase split errors at current parameters  
        for i in range(len(p.m['x1'])):
            # Uptate T, P INCLUDE THIS IN RELEVANT FUNCTION
            s.s['P'], s.s['T'] = p.m['P'][i], p.m['T'][i]
            s.m['P'], s.c[1]['P'], s.c[2]['P'] = (s.s['P'],)*3
            s.m['T'], s.c[1]['T'], s.c[2]['T'] = (s.s['T'],)*3

            s, p = phase_split(s, p, est = [min(p.m['x1'][i], p.m['y1'][i]), \
                                            max(p.m['x1'][i], p.m['y1'][i])])

#            if i == 103:
#                print 'x = {}, y = {}'.format(s.m['x1'],s.m['y1'])
                                            
            err+= (p.m['x1'][i] - s.m['x1'])**2 + (p.m['y1'][i] - s.m['y1'])**2
            
        print 'done' # DEBUGGING REMOVE
        return err
        
    #error(0.0135,s,p)
    #error(0.011,s,p)

    k12_0 = array([0.0135]) # Initial guess
    Bounds = [(0,1.0)]
    #mininum = fmin_l_bfgs_b(error, k12_0, args=(s,p), bounds=Bounds,
    #                        approx_grad=True)
    
    #s.m['minimum'] = minimum
    #anneal
    return s, p

#%% Plot functions
def plot_dg_mix(s,p):
    '''TO DO: Update'''
    from matplotlib import rc
    from matplotlib import pyplot as plot
    from numpy import array
    
    def plotprop(x, name, overall, liquid=None, vapour=None):
    	if overall is not None:
    		plot.plot(x, overall, 'g', label='Overall')
    	if liquid is not None:
    		plot.plot(x, liquid, 'b', label='Liquid')
    	if vapour is not None:
    		plot.plot(x, vapour, 'r', label='Vapour')
    	plot.xlabel(r"$x_1$", fontsize=14)
    	plot.ylabel(name, fontsize=14)
    
    valm, idx = max((valm, idx) for (idx, valm) in \
    enumerate(array(s.s['del g_mix l soln']) - array(s.s['del g_mix v soln'])))
    
    plot.rcParams.update(I['Plot options'])
    plot.figure(5)
    plotprop(s.c[1]['x_range'], r"$\Delta$g", 
             s.s['del g_mix soln'], s.s['del g_mix l soln'], 
             s.s['del g_mix v soln'])
             
    plot.plot([s.s['Data x1'],s.s['Data y1']], [s.s['Data gx1'],
               s.s['Data gy1']],'k')
    #plot.figure(2)
    #plotprop(s.c[1]['x_range'], 'Volumes', None, stores['V_l_m'],
    #           stores['V_l_m'])
    plot.figure(50)
    plotprop(s.c[1]['x_range'], '$\Delta g_{mix}^l - \Delta g_{mix}^v $',  
             array(s.s['del g_mix l soln']) - array(s.s['del g_mix v soln']) )
    plot.text(s.c[1]['x_range'][idx], valm+0.000006, "%f" %round(p.m['k12'],6))

#%%
if __name__ == '__main__':
    #%% Load Data
    try: # Dectect input, use local script if not defined then import data
        Compounds = I['Compounds'] # Variable to draw data in data_handling.py
        data = data_handling.ImportData()  
        data.load_pure_data(I['Compounds'])
        data.load_VLE(Compounds)
    except(KeyError,NameError): # Define local inputs if I is not found.
        I = inputs() # 
        Compounds = I['Compounds'] # Variable to draw data in data_handling.py
        data = data_handling.ImportData()  
        data.load_pure_data(I['Compounds'])
        data.load_VLE(Compounds)
        #execfile('data_handling.py') # Load data

    #%% Find pure component model parameters if not defined    
    for compound in I['Compounds']:
        if False:# TO DO TRY EXCEPTION HANDLING TO DETECT NEEDED PARAMS
            I['Compound'] = [compound]
            execfile('pure.py')
   
    #%% Initialize binary and single component paramters
    p = MixParameters() 
    p.parameters(data.c[0],I) # Defines p.c[1]
    p.parameters(data.c[1],I) # Defines p.c[2]
    p.mixture_parameters(data.VLE,I)
    p.m['R'] = p.c[1]['R'] # Use a component Universal gas constant

    #%% Initialize state variables
    s = state()
    s.mixed() # Define mix state variable, call using s.m['key']
    # Define three component state variables (use index 1 and 2 for clarity)
    s.pure(), s.pure()  # Call using s.c[1]['key'] and s.c[2]['key']
    
    #%% Find mixture model parameters if not defined
    if I['Mixture model'] == 'VdW standard':
        #if p.m['k12'] == '':
        if True: # TESTING p.m['k12']; DELETE
            p.m['k12'] = 0.0135
            optim_mixture_parameter(s, p)
            #s, p = optim_mixture_parameter(s, p) # Find k1 for VLE data set.

    #%% Find phase equilibrium at specified T, P point
    if False:
    #if I['Phase split']:
        if I['T'] and I['P']:
            p.m['k12'] = 0.0135 # DEBUGGING
            # Upate P, T state
            s.s['P'], s.s['T'] = I['P'], I['T'] 
            # b11 and b22 taken as the critical parameters
            s.c[1]['b'], s.c[2]['b'] = p.c[1]['b_c'], p.c[2]['b_c']  
            s.m['P'], s.c[1]['P'], s.c[2]['P'] = (s.s['P'],)*3
            s.m['T'], s.c[1]['T'], s.c[2]['T'] = (s.s['T'],)*3
            p.m['Plot binary'] = I['Plot binary']
            s, p = phase_split(s, p, est=[0.556,0.55])
            print s.m['ans']
            print s.m['ans'][1] - s.m['ans'][0]
            

            #%%
            
            if p.m['Plot binary']: 
                pass
                #g_range(s, p, x_r=100)
                #plot_dg_mix(s,p)
        else:
            raise IOError('No Temperature or Pressure point specified')
       
         # a_c[0] = a_c11 | a_c[1] = a_c22    
        
          #   'T'           : 281.15,  
          #   'P'           : 5663.534211
    
        # datapoint = array([0.2027,0.2567]) # @ P = 6.278150329 T = 281.15 
        # datapoint = array([0.9618,0.9297]) # @ P = 5.663534211  T = 281.15    
        # datapoint = array([0.4535,0.4605]) # @ P = 6492.799322 T = 281.15    
             
        #%% TESTS AND DEBUGGING
        #s, p = phase_split(s,p,x_r=200)
        from numpy import linspace
        if False:
            for p.m['k12'] in linspace(0.03125,0.0325,5):  # TESTS linspace(0.05+ 1e-30,0.07,30)
                print p.m['k12'] # TEST; DELETE
                s, p = phase_split(s,p,x_r=200)
            
        if False:
            for p.m['k12'] in linspace(0.011,0.033,5):
                print p.m['k12'] # TEST; DELETE
                s, p = phase_split(s,p,x_r=200)
                
    #%% Find phase equilibrium at specified T, P point

    
    #%% Plotting if True
    
    #%% !!! NB NB NB !!! Remember to revert indiced from 1,2 back to [0] [1] 
    # when saving data from s or p components


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    